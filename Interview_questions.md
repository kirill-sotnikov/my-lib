# Вопросов с собеседования JavaScript-разработчика

1. **В чем смысл оборачивания всего содержимого JavaScript-файла в функцию?**

   Этот шаблон называется IIFE - Immediately Invoked Function Expression (немедленно вызываемое функциональное выражение). Этот подход позволяет:

   - обеспечить коду собственный блок видимости, то-есть контекст выполнения
   - избежать загрязнения глобальной области видимости глобальными переменными
   - избежать неумышленного переопределения уже существующих переменных в глобальной области видимости

   ```js
   // пример IIFE. Данную функцию не нужно нигде вызывать, она сама вызывает себя сразу
   (function () {
     console.log("hello");
   })();
   ```

2. **В чем смысл и польза указания use strict в начале JavaScript-файла?**

   Команда use strict включает так называемый строгий режим. В этом режиме предупреждения становятся ошибками, что помогает в написании более чистого и безопасного кода, менее уязвимого к ошибкам.

3. **Что такое NaN? Какого типа это значение? Как можно узнать, равно ли значение переменной NaN?**

   NaN расшифровывается как "Not A Number", это "falsey" (ложное) значение.

   Выражение typeof NaN возвращает тип Number.

   Проверить значение переменной на соответствие NaN можно, воспользовавшись встроенным методом isNaN() или используя оператор тройного равенства ===.

4. **Что такое замыкание в JavaScript?**

   Замыкание в JavaScript - это комбинация функции и лексического окружения, в котором она была определена. Это позволяет ей обращаться к переменным и функциям этого лексического окружения в дальнейшем.

   ```js
   //↓ внешняя функция
   function makeCounter() {
     let counter = 0;

     //       ↓ внутренняя функция
     return function () {
       return (counter += 1);
     };
   }

   const counterA = makeCounter();

   console.log(counterA()); // 1
   console.log(counterA()); // 2
   ```

   > _Объяснение._ Функция внутри makeCounter обращается к переменной counter, которая находится в функции-родителя. Взаимодействие внутренней функции с элементами внешней называется замыканием.

5. **Как можно клонировать объект?**

   Клонирование объекта со всеми его значениями.

   ```js
   const cloneObject = JSON.parse(JSON.stringify(objectToClone));
   ```

6. **Как можно добавить элемент в начало и в конец массива?**

   Чтобы добавить элемент в начало массива, можно использовать [массив].unshift(). Для добавления элемента в конец массива подойдет [массив].push().

7. **В чем разница между undefined и is not defined?**

   undefined - это значение, присваемое объявленной, но не проинициализированной переменной.

   > _Пояснение_. Не проинициализированной переменной - переменная, которой не было задано какое-либо значение. Переменная (а) в примере ниже именно такой и является.

   is not defined - это ошибка, которую мы получаем, когда обращаемся к несуществующей переменной.

   ```js
   // Пример

   let a;
   console.log(a); //undefined

   console.log(b); // is not defined
   ```

8. **Как проверить, является ли объект массивом?**

   Для этого можно использовать встроенный метод Array.isArray().

   ```js
   const b = ["i", "am", "human"];

   console.log(Array.isArray(b)); // true
   ```

9. **Что такое hoisting (поднятие) в JavaScript?**

   Поднятие - это поведение компилятора JavaScript, заключающееся в поднятии объявлений переменных и функций в начало области видимости.

   Благодаря поднятию мы можем использовать функции и переменные до их объявления в коде. Однако, следовать учитывать, что поднимаются только объявления, но не присваивания значений.

   По этой причине, например, мы можем использовать до объявления функцию, объявленную через Function Declaration, но не можем ту, которая объявлена через Function Expression.

   ```js
   console.log(aLet); // Ошибка!
   console.log(bConst); // Ошибка!
   console.log(cVar); // undefined - переменная объявлена, но значение еще не задано.
   console.log(write()); //  Выполнется
   console.log(read()); // Ошибка!

   let aLet = 10;

   const bConst = 20;

   var cVar = 5; // объявление через var поднимает объявление переменной вверх области видимости.

   function write() {} // functio Declaration

   const read = () => {}; // function Expression
   ```

   > На интервью любят справшивать про хостинг, особенно про var.

10. **Что такое this?**

    this указывает на объект области видимости во время выполнения. По умолчанию this указывает на глобальный объект. В браузере выражение this равно window. Также this принято называть контекстом.

    ```js
    const a = {
      prop: 10,
      getProp() {
        return this.prop;
      },
    };

    console.log(a.getProp()); // 10
    ```

11. **Как работает прототипное наследование?**

    В JavaScript все является объектами. Эти объекты связаны цепочками прототипов, по которым им передаются методы и свойства. При обращении к свойству или методу объекта сначала происходит поиск этого свойства у самого объекта. В случае неудачи поиск перенаправляется в его прототип, затем в прототип прототипа и так далее, пока искомое свойство не будет найдено, либо пока не закончится цепочка прототипов.

12. **Чем разница между null и undefined?**

    undefined - это значение переменной, которую объявили, но не дали ей значени (другимим словами - не инициализировали)

    null - это пустота, можно испоьлзоаввть это значение для того, чтобы явно указать, что значение пустое.

13. **В чем разница между методами массива .forEach и .map?**

    forEach - просто выполняет функцию, которую ему передали как аргумент с каждым элементом массива.

    map - с каждым значением массива выполняет функцию, которую ему передали как аргумент, после чего возвращает получившийся результат.

    ```js
    const array = [1, 2, 3, 4, 5];

    const a = array.forEach((item) => item * 2);
    const b = array.map((item) => item * 2);

    console.log(a); // undefined, так как forEach ничего не возвращает.
    console.log(b);
    ```

    > forEach похож на функцию без return.

14. **В каких случаях используются анонимные функции?**

    Анонимные функции чаще всего используются в качестве функций обратных вызовов (callback) . Также, каждая стрелочная функция является анонимной.

    ```js
    // функция переданная как аргумент map является callback'ом.
    array.map(()=>{})

    // Примеры анонимных функций:

    function(){}

    ()=>{}

    (function(){})() // эту функцию в callback использовать нельзя
    ```

15. **Разница между const person = Person() и const person = new Person() при function Person(){}**

    Если функция Person() не возвращает явным образом создаваемый экземпляр, то вариант const person = Person() присвоит константе person значение undefined, поскольку именно таков результат void функции.

    Если функция Person явным образом возвращает экземпляр, он станет значением константы person при const person = Person().

    Однако, вариант с использование оператора new "выигрывает", поскольку он устанавливает корректную связь объекта person с цепочкой прототипов Person, в то время как выражение const person = Person() просто присваивает константе результат вызова функции.

16. **В чем разница между Function.prototype.call и Function.prototype.apply?**

    Оба метода вызывают исходный метод с подмененным контекстом, но .call принимает параметры через запятую, а .apply - массивом.

17. **Как работает Function.prototype.bind?**

    Данный метод возвращает функцию с подмененным контекстом.

    ```js
    const objOne = {
      value: 10,

      getValue() {
        return this.value;
      },
    };

    const objTwo = {
      value: 5,
    };

    const f = objOne.getValue.bind(objTwo);
    console.log(f()); // 5
    ```

    > Объяснение. Мы присвоили переменной f метод getValue, но из-за того, что мы задали ему новый контекст с помощью .bind(), f() теперь возвращает не value заданное в objOne, а value заданное в objTwo.

18. **Что вы знаете об AJAX?**

    AJAX — подход к построению интерактивных пользовательских интерфейсов веб-приложений, заключающийся в «фоновом» обмене данными браузера с веб-сервером. В результате при обновлении данных веб-страница не перезагружается полностью, и веб-приложения становятся быстрее и удобнее.

    !!! СДелать две гифки-примеры с ajax и без ajax.
